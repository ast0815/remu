

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>remu.binning &mdash; ReMU  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/ReMU.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/README.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/README.html">An example analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/README.html">Module references</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ReMU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">remu.binning</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for remu.binning</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Binning/histogramming classes for scientific computing</span>

<span class="sd">YAML interface</span>
<span class="sd">==============</span>

<span class="sd">All classes defined in `binning` can be stored as and read from YAML files</span>
<span class="sd">using the ``binning.yaml`` module::</span>

<span class="sd">    with open(&quot;filename.yml&quot;, &#39;w&#39;) as f:</span>
<span class="sd">        binning.yaml.dump(some_binning, f)</span>

<span class="sd">    with open(&quot;filename.yml&quot;, &#39;r&#39;) as f:</span>
<span class="sd">        some_binning = binning.yaml.full_load(f)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">TemporaryFile</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">from</span> <span class="nn">numpy.lib.recfunctions</span> <span class="kn">import</span> <span class="n">rename_fields</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">yaml_compat</span>

<span class="c1"># Use this function/object for parallelization where possible</span>
<span class="n">mapper</span> <span class="o">=</span> <span class="nb">map</span>


<div class="viewcode-block" id="PhaseSpace">
<a class="viewcode-back" href="../../modules/binning/PhaseSpace.html#remu.binning.PhaseSpace">[docs]</a>
<span class="k">class</span> <span class="nc">PhaseSpace</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">YAMLObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A PhaseSpace defines the possible combinations of variables that characterize an event.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    variables : iterable of strings</span>
<span class="sd">        The set of variables that define the phase space.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    variables : set of str</span>
<span class="sd">        The set of variables that define the phase space.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A PhaseSpace can be seen as the carthesian product of its `variables`::</span>

<span class="sd">        &gt;&gt;&gt; ps = PhaseSpace(variables=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; print ps</span>
<span class="sd">        (&#39;a&#39; X &#39;c&#39; X &#39;b&#39;)</span>

<span class="sd">    You can check whether a variable is part of a phase space::</span>

<span class="sd">        &gt;&gt;&gt; &#39;a&#39; in ps</span>
<span class="sd">        True</span>

<span class="sd">    Phase spaces can be compared to one another.</span>

<span class="sd">    Check whether two phase spaces are identical::</span>

<span class="sd">        &gt;&gt;&gt; PhaseSpace([&#39;a&#39;,&#39;b&#39;]) == PhaseSpace([&#39;b&#39;, &#39;a&#39;])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; PhaseSpace([&#39;a&#39;, &#39;b&#39;]) == PhaseSpace([&#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; PhaseSpace([&#39;a&#39;, &#39;b&#39;]) != PhaseSpace([&#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">        True</span>

<span class="sd">    Check whether one phase space is a sub-space of the other::</span>

<span class="sd">        &gt;&gt;&gt; PhaseSpace([&#39;a&#39;, &#39;b&#39;,&#39;c&#39;)] &gt; PhaseSpace([&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; PhaseSpace([&#39;a&#39;, &#39;c&#39;]) &lt; PhaseSpace([&#39;a&#39;, &#39;b&#39;,&#39;c&#39;])</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">==</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">!=</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">&lt;=</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">&gt;=</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">&lt;=</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">==</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">&gt;=</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">==</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PhaseSpace</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">|</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PhaseSpace</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">-</span> <span class="n">phasespace</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phasespace</span><span class="p">):</span>
        <span class="c1"># Python 3 div operator</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">phasespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;(&#39;&quot;</span> <span class="o">+</span> <span class="s2">&quot;&#39; X &#39;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;)&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(variables=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="si">!r}</span><span class="s2">)&quot;</span>

<div class="viewcode-block" id="PhaseSpace.clone">
<a class="viewcode-back" href="../../modules/binning/PhaseSpace.html#remu.binning.PhaseSpace.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="PhaseSpace.to_yaml">
<a class="viewcode-back" href="../../modules/binning/PhaseSpace.html#remu.binning.PhaseSpace.to_yaml">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dumper</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_sequence</span><span class="p">(</span><span class="s2">&quot;!PhaseSpace&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span></div>


<div class="viewcode-block" id="PhaseSpace.from_yaml">
<a class="viewcode-back" href="../../modules/binning/PhaseSpace.html#remu.binning.PhaseSpace.from_yaml">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">construct_sequence</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="n">seq</span><span class="p">)</span></div>


    <span class="n">yaml_loader</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">FullLoader</span>
    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!PhaseSpace&quot;</span></div>



<div class="viewcode-block" id="Bin">
<a class="viewcode-back" href="../../modules/binning/Bin.html#remu.binning.Bin">[docs]</a>
<span class="k">class</span> <span class="nc">Bin</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">YAMLObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Bin is a container for a value that is defined on a subset of an n-dimensional phase space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the `Bin` resides in.</span>
<span class="sd">    value : float, optional</span>
<span class="sd">        The initialization value of the bin. Default: 0.0</span>
<span class="sd">    entries : int, optional</span>
<span class="sd">        The initialization value of the number of entries. Default: 0</span>
<span class="sd">    sumw2 : float, optional</span>
<span class="sd">        The initialization value of the sum of squared weights. Default: ``value**2``</span>
<span class="sd">    value_array : slice of ndarray, optional</span>
<span class="sd">        A slice of a numpy array, where the value of the bin will be stored.</span>
<span class="sd">        Default: ``None``</span>
<span class="sd">    entries_array : slice of ndarray, optional</span>
<span class="sd">        A slice of a numpy array, where the number entries will be stored.</span>
<span class="sd">        Default: ``None``</span>
<span class="sd">    sumw2_array : slice of ndarray, optional</span>
<span class="sd">        A slice of a numpy array, where the squared weights will be stored.</span>
<span class="sd">        Default: ``None``</span>
<span class="sd">    dummy : bool, optional</span>
<span class="sd">        Do not create a any arrays to store the data.</span>
<span class="sd">        Default: ``False``</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    value : float</span>
<span class="sd">        The value of the bin.</span>
<span class="sd">    entries : int</span>
<span class="sd">        The number of entries in the bin.</span>
<span class="sd">    sumw2 : float</span>
<span class="sd">        The sum of squared weights in the bin.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the bin is defined on</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;phasespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Undefined phase space!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;dummy&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;value_array&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;entries_array&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;entries&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sumw2_array&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sumw2&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">**</span><span class="mi">2</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;value_array&quot;</span><span class="p">,</span> <span class="s2">&quot;entries_array&quot;</span><span class="p">,</span> <span class="s2">&quot;sumw2_array&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown kwargs: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(float) The value of the bin.</span>

<span class="sd">        The sum of weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">entries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(int) The number of entries in the bin.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@entries</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">entries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sumw2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(float) The sum of squared weights in the bin.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@sumw2</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sumw2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

<div class="viewcode-block" id="Bin.event_in_bin">
<a class="viewcode-back" href="../../modules/binning/Bin.html#remu.binning.Bin.event_in_bin">[docs]</a>
    <span class="k">def</span> <span class="nf">event_in_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the variable combination falls within the bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : dict like</span>
<span class="sd">            A dictionary (or similar object) with one value of each variable</span>
<span class="sd">            in the binning, e.g.::</span>

<span class="sd">                {&#39;x&#39;: 1.4, &#39;y&#39;: -7.47}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        bool</span>
<span class="sd">            Whether or not the variable combination lies within the bin.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method must be defined in an inheriting class.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Bin.fill">
<a class="viewcode-back" href="../../modules/binning/Bin.html#remu.binning.Bin.fill">[docs]</a>
    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the weight(s) to the bin.</span>

<span class="sd">        Also increases the number of entries and sum of squared weights accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        weight : float or iterable of floats, optional</span>
<span class="sd">            Weight(s) to be added to the value of the bin.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Does the weight have a length?</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># No</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Yes</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entries</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumw2</span> <span class="o">+=</span> <span class="n">w2</span></div>


<div class="viewcode-block" id="Bin.is_dummy">
<a class="viewcode-back" href="../../modules/binning/Bin.html#remu.binning.Bin.is_dummy">[docs]</a>
    <span class="k">def</span> <span class="nf">is_dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if there is no data array linked to this bin.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the event falls within the bin.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_in_bin</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bins are equal if they are of the same type, defined on the same phase space.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">phasespace</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">entries</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">sumw2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">sumw2</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Python 3 div operator</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()]),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;phasespace&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dummy</span><span class="p">()</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dummy&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dummy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;value_array&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">),</span>
                    <span class="s2">&quot;entries_array&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">),</span>
                    <span class="s2">&quot;sumw2_array&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Bin.clone">
<a class="viewcode-back" href="../../modules/binning/Bin.html#remu.binning.Bin.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a functioning copy of the Bin.</span>

<span class="sd">        Can specify additional kwargs for the initialisation of the new Binning.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Bin.to_yaml">
<a class="viewcode-back" href="../../modules/binning/Bin.html#remu.binning.Bin.to_yaml">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dumper</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_dummy</span><span class="p">():</span>
            <span class="k">del</span> <span class="n">dic</span><span class="p">[</span><span class="s2">&quot;dummy&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_mapping</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">yaml_tag</span><span class="p">,</span> <span class="n">dic</span><span class="p">)</span></div>


<div class="viewcode-block" id="Bin.from_yaml">
<a class="viewcode-back" href="../../modules/binning/Bin.html#remu.binning.Bin.from_yaml">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">dic</span><span class="p">)</span></div>


    <span class="n">yaml_loader</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">FullLoader</span>
    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!Bin&quot;</span></div>



<div class="viewcode-block" id="RectangularBin">
<a class="viewcode-back" href="../../modules/binning/RectangularBin.html#remu.binning.RectangularBin">[docs]</a>
<span class="k">class</span> <span class="nc">RectangularBin</span><span class="p">(</span><span class="n">Bin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Bin defined by min and max values in all variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    variables : iterable of str</span>
<span class="sd">        The variables with defined edges.</span>

<span class="sd">    edges : iterable of (int, int)</span>
<span class="sd">        lower and upper edges for all variables::</span>

<span class="sd">            [[x_lower, x_upper], [y_lower, y_upper], ...]</span>

<span class="sd">    include_lower : bool, optional</span>
<span class="sd">        Does the bin include the lower edges?</span>

<span class="sd">    include_upper : bool, optional</span>
<span class="sd">        Does the bin include the upper edges?</span>

<span class="sd">    **kwargs : optional</span>
<span class="sd">        Additional keyword arguments are passed to :class:`Bin`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    value : float</span>
<span class="sd">        The value of the bin.</span>
<span class="sd">    entries : int</span>
<span class="sd">        The number of entries in the bin.</span>
<span class="sd">    sumw2 : float</span>
<span class="sd">        The sum of squared weights in the bin.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the bin is defined on</span>
<span class="sd">    variables : tuple of str</span>
<span class="sd">        The variable names.</span>
<span class="sd">    edges : tuple of (int, int)</span>
<span class="sd">        The bin edges for each variable.</span>
<span class="sd">    include_lower : bool</span>
<span class="sd">        Does the bin include the lower edges?</span>
<span class="sd">    include_upper : bool</span>
<span class="sd">        Does the bin include the upper edges?</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">include_lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">include_lower</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">include_upper</span><span class="p">)</span>

        <span class="c1"># Create PhaseSpace from edges if necessary</span>
        <span class="n">phasespace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phasespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phasespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;phasespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PhaseSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>

        <span class="c1"># Handle default bin initialization</span>
        <span class="n">Bin</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Check that all edges are valid tuples</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable not part of PhaseSpace: </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ma</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Upper edge is smaller than lower edge for variable </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

<div class="viewcode-block" id="RectangularBin.event_in_bin">
<a class="viewcode-back" href="../../modules/binning/RectangularBin.html#remu.binning.RectangularBin.event_in_bin">[docs]</a>
    <span class="k">def</span> <span class="nf">event_in_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether an event is within all bin edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : dict like</span>
<span class="sd">            A dictionary (or similar object) with one value of each variable</span>
<span class="sd">            in the binning, e.g.::</span>

<span class="sd">                {&#39;x&#39;: 1.4, &#39;y&#39;: -7.47}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        bool</span>
<span class="sd">            Whether or not the variable combination lies within the bin.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inside</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">event</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">mi</span><span class="p">:</span>
                    <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">mi</span><span class="p">:</span>
                    <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">ma</span><span class="p">:</span>
                    <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">ma</span><span class="p">:</span>
                    <span class="n">inside</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">inside</span></div>


<div class="viewcode-block" id="RectangularBin.get_center">
<a class="viewcode-back" href="../../modules/binning/RectangularBin.html#remu.binning.RectangularBin.get_center">[docs]</a>
    <span class="k">def</span> <span class="nf">get_center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bin center coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ndarray</span>
<span class="sd">            The center coordinates for each variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;RectangularBins are equal if they have the same edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">Bin</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
            <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">include_lower</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">include_upper</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;include_upper&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
            <span class="s2">&quot;include_lower&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_lower</span><span class="p">,</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span>
            <span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="p">}</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Bin</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!RectangularBin&quot;</span></div>



<div class="viewcode-block" id="CartesianProductBin">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBin.html#remu.binning.CartesianProductBin">[docs]</a>
<span class="k">class</span> <span class="nc">CartesianProductBin</span><span class="p">(</span><span class="n">Bin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Bin that is part of a CartesianProductBinning.</span>

<span class="sd">    An event is part of a bin, if it has the right data indices in the</span>
<span class="sd">    constituent binnings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    binnings : iterable of Binning</span>
<span class="sd">    data_indices : iterable of int</span>
<span class="sd">        Specifies the constituent binnings and the respective data indices.</span>
<span class="sd">    **kwargs : optional</span>
<span class="sd">        Additional keyword arguments are passed to :class:`Bin`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    value : float</span>
<span class="sd">        The value of the bin.</span>
<span class="sd">    entries : int</span>
<span class="sd">        The number of entries in the bin.</span>
<span class="sd">    sumw2 : float</span>
<span class="sd">        The sum of squared weights in the bin.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the bin is defined on</span>
<span class="sd">    binnings : tuple of Binning</span>
<span class="sd">    data_indices : tuple of int</span>
<span class="sd">        Specifies the constituent binnings and the respective data indices.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binnings</span><span class="p">,</span> <span class="n">data_indices</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">binnings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data_indices</span><span class="p">)</span>

        <span class="c1"># Create PhaseSpace from binnings if necessary</span>
        <span class="k">if</span> <span class="s2">&quot;phasespace&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;phasespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PhaseSpace</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;phasespace&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="n">binning</span><span class="o">.</span><span class="n">phasespace</span>

        <span class="n">Bin</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="CartesianProductBin.event_in_bin">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBin.html#remu.binning.CartesianProductBin.event_in_bin">[docs]</a>
    <span class="k">def</span> <span class="nf">event_in_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether an event is within the bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : dict like</span>
<span class="sd">            A dictionary (or similar object) with one value of each variable</span>
<span class="sd">            in the binning, e.g.::</span>

<span class="sd">                {&#39;x&#39;: 1.4, &#39;y&#39;: -7.47}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        bool</span>
<span class="sd">            Whether or not the variable combination lies within the bin.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check that the event is at the right data position in all binnings</span>
        <span class="k">for</span> <span class="n">binning</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_indices</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">binning</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="CartesianProductBin.get_marginal_bins">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBin.html#remu.binning.CartesianProductBin.get_marginal_bins">[docs]</a>
    <span class="k">def</span> <span class="nf">get_marginal_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the corresponding bins on the input binnings of the cartesian product.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        (bin_1, bin_2[, bin_3 ...])</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        get_marginal_subbins</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_indices</span><span class="p">):</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">bins</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">get_data_bin_index</span><span class="p">(</span><span class="n">d</span><span class="p">)],)</span>

        <span class="k">return</span> <span class="n">bins</span></div>


<div class="viewcode-block" id="CartesianProductBin.get_marginal_subbins">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBin.html#remu.binning.CartesianProductBin.get_marginal_subbins">[docs]</a>
    <span class="k">def</span> <span class="nf">get_marginal_subbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the corresponding subbins on the input binnings of the cartesian product.</span>

<span class="sd">        This will return a tuple of tuples of subbins. One tuple for each input binning.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ((bin_1, [subbin_1a ...]), (bin_2, [subbin_2a ...]) [, (bin_3, [subbin_3a ...]) ...])</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        get_marginal_bins</span>
<span class="sd">        Binning.get_subbins</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_indices</span><span class="p">):</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_subbins</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_data_bin_index</span><span class="p">(</span><span class="n">d</span><span class="p">)),)</span>

        <span class="k">return</span> <span class="n">bins</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CartesianProductBins are equal, if the binnings and indices are equal.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binnings</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Try both combinations of self and other</span>
            <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)]:</span>
                <span class="k">for</span> <span class="n">self_binning</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">binnings</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">data_indices</span><span class="p">):</span>
                    <span class="c1"># For each binning and index in self...</span>
                    <span class="k">for</span> <span class="n">other_binning</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">binnings</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">data_indices</span><span class="p">):</span>
                        <span class="c1"># ... check that there is a matchin binning and index in other</span>
                        <span class="k">if</span> <span class="n">self_binning</span> <span class="o">==</span> <span class="n">other_binning</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Otherwise return `False`</span>
                        <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Found a match for all elements</span>
            <span class="k">return</span> <span class="n">Bin</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;binnings&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">binning</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">],</span>
            <span class="s2">&quot;data_indices&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_indices</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Bin</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!CartesianProductBin&quot;</span></div>



<div class="viewcode-block" id="Binning">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning">[docs]</a>
<span class="k">class</span> <span class="nc">Binning</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">YAMLObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Binning is a set of disjunct Bins.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    bins : list of Bin</span>
<span class="sd">        The list of disjoint bins.</span>
<span class="sd">    subbinnings : dict of {bin_index: Binning}, optional</span>
<span class="sd">        Subbinnings to replace certain bins.</span>
<span class="sd">    value_array : slice of ndarray, optional</span>
<span class="sd">        A slice of a numpy array, where the values of the bins will be stored.</span>
<span class="sd">    entries_array : slice of ndarray, optional</span>
<span class="sd">        A slice of a numpy array, where the number of entries will be stored.</span>
<span class="sd">    sumw2_array : slice of ndarray, optional</span>
<span class="sd">        A slice of a numpy array, where the squared weights will be stored.</span>
<span class="sd">    phasespace : PhaseSpace, optional</span>
<span class="sd">        The :class:`PhaseSpace` the binning resides in.</span>
<span class="sd">    dummy : bool, optional</span>
<span class="sd">        Do not create any arrays to store the data.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    bins : tuple of Bin</span>
<span class="sd">        The list of disjoint bins on the PhaseSpace.</span>
<span class="sd">    nbins : int</span>
<span class="sd">        The number of bins in the binning.</span>
<span class="sd">    data_size : int</span>
<span class="sd">        The number of elements in the data arrays.</span>
<span class="sd">        Might differ from ``nbins`` due to subbinnings.</span>
<span class="sd">    subbinnings : dict of {bin_index: Binning}, optional</span>
<span class="sd">        Subbinnings to replace certain bins.</span>
<span class="sd">    value_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the values of the bins are stored.</span>
<span class="sd">    entries_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the number of entries are stored.</span>
<span class="sd">    sumw2_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the squared weights are stored.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the binning resides in.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Subbinnings are used to get a finer binning within a given bin. The bin to</span>
<span class="sd">    be replaced by the finer binning is specified using the *native* bin</span>
<span class="sd">    index, i.e. the number it would have before the sub binnings are assigned.</span>
<span class="sd">    Subbinnings are inserted into the numpy arrays at the position of the</span>
<span class="sd">    original bins. This changes the *effective* bin number of all later bins.</span>

<span class="sd">    The data itself is stored in Numpy arrays (or views of such) that are</span>
<span class="sd">    managed by the :class:`Binning`. The arrays are linked to the contained</span>
<span class="sd">    :class:`Bin` objects and subbinnings by setting their respective storage</span>
<span class="sd">    arrays to sliced views of the data arrays. The original arrays in the bins</span>
<span class="sd">    and subbinnings will always be replaced.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bins</span><span class="p">,</span>
        <span class="n">subbinnings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">entries_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sumw2_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">phasespace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dummy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">_BinProxy</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subbinnings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">subbinnings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span> <span class="o">=</span> <span class="n">phasespace</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_phasespace</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span>
        <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_size</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">binning</span><span class="o">.</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="p">)</span>  <span class="c1"># Minus one, since one bin gets replaced</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dummy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="o">=</span> <span class="n">value_array</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_size</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Value array shape is not same as (data_size,)!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span> <span class="o">=</span> <span class="n">entries_array</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_size</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Entries array shape is not same as (data_size,)!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="o">=</span> <span class="n">sumw2_array</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_size</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Sumw2 array shape is not same as (data_size,)!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">link_arrays</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_phasespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get PhaseSpace from Bins and subbinnings.&quot;&quot;&quot;</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">PhaseSpace</span><span class="p">([])</span>
        <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">:</span>
            <span class="n">ps</span> <span class="o">*=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">phasespace</span>
        <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ps</span> <span class="o">*=</span> <span class="n">binning</span><span class="o">.</span><span class="n">phasespace</span>
        <span class="k">return</span> <span class="n">ps</span>

<div class="viewcode-block" id="Binning.link_arrays">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.link_arrays">[docs]</a>
    <span class="k">def</span> <span class="nf">link_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Link the data storage arrays into the bins and sub_binnings.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_link_bins</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_link_subbinnings</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_link_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="nb">bin</span><span class="o">.</span><span class="n">value_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="nb">bin</span><span class="o">.</span><span class="n">entries_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="nb">bin</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_link_subbinnings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">data_size</span>
            <span class="n">binning</span><span class="o">.</span><span class="n">value_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
            <span class="n">binning</span><span class="o">.</span><span class="n">entries_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
            <span class="n">binning</span><span class="o">.</span><span class="n">sumw2_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span><span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
            <span class="c1"># Also make the subbinnings link the new arrays</span>
            <span class="n">binning</span><span class="o">.</span><span class="n">link_arrays</span><span class="p">()</span>

<div class="viewcode-block" id="Binning.get_event_data_index">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_event_data_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_event_data_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the data array index of the given event.</span>

<span class="sd">        Returns `None` if the event does not belong to any bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : dict like</span>
<span class="sd">            A dictionary (or similar object) with one value of each variable</span>
<span class="sd">            in the binning, e.g.::</span>

<span class="sd">                {&#39;x&#39;: 1.4, &#39;y&#39;: -7.47}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        int or None</span>
<span class="sd">            The bin number</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        get_event_bin_index</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bin_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_bin_index</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="n">data_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">bin_i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
            <span class="n">data_i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">bin_i</span><span class="p">]</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_i</span></div>


<div class="viewcode-block" id="Binning.get_event_bin_index">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_event_bin_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_event_bin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the bin number of the given event.</span>

<span class="sd">        Returns `None` if the event does not belong to any bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : dict like</span>
<span class="sd">            A dictionary (or similar object) with one value of each variable</span>
<span class="sd">            in the binning, e.g.::</span>

<span class="sd">                {&#39;x&#39;: 1.4, &#39;y&#39;: -7.47}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        int or None</span>
<span class="sd">            The bin number</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The bin number can be used to access the corresponding :class:`Bin`,</span>
<span class="sd">        or the subbinning in that bin (if it exists)::</span>

<span class="sd">            i = binning.get_event_bin_index(event)</span>
<span class="sd">            binning.bins[i]</span>
<span class="sd">            binning.subbinnings[i]</span>

<span class="sd">        This is *not* the same as the corresponding index in the data array if</span>
<span class="sd">        there are any subbinnings present.</span>

<span class="sd">        This is a dumb method that just loops over all bins until it finds a</span>
<span class="sd">        fitting one. It should be replaced with something smarter for more</span>
<span class="sd">        specifig binning classes.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>

<span class="sd">        get_event_data_index</span>
<span class="sd">        get_event_bin</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">i</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Binning.get_bin_data_index">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_bin_data_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bin_data_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the data array index from the bin number.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bin_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">data_i</span> <span class="o">=</span> <span class="n">bin_i</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bin_i</span><span class="p">:</span>
                <span class="n">data_i</span> <span class="o">=</span> <span class="n">data_i</span> <span class="o">+</span> <span class="p">(</span>
                    <span class="n">binning</span><span class="o">.</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">)</span>  <span class="c1"># Minus one, because the original bin is replaced</span>
        <span class="k">return</span> <span class="n">data_i</span></div>


<div class="viewcode-block" id="Binning.get_data_bin_index">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_data_bin_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_data_bin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the bin number from the data array index.</span>

<span class="sd">        All data indices inside a subbinning will return the bin index of that</span>
<span class="sd">        subbinning.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data_i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">bin_i</span> <span class="o">=</span> <span class="n">data_i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">bin_i</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">bin_i</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data_size</span> <span class="o">&gt;</span> <span class="n">bin_i</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
            <span class="n">bin_i</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data_size</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">bin_i</span></div>


<div class="viewcode-block" id="Binning.get_event_bin">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_event_bin">[docs]</a>
    <span class="k">def</span> <span class="nf">get_event_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the bin of the event.</span>

<span class="sd">        Returns `None` if the event does not fit in any bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : dict like</span>
<span class="sd">            A dictionary (or similar object) with one value of each variable</span>

<span class="sd">            in the binning, e.g.::</span>

<span class="sd">                {&#39;x&#39;: 1.4, &#39;y&#39;: -7.47}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Bin or None</span>
<span class="sd">            The :class:`Bin` object the event fits into.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_bin_index</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Binning.get_subbins">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_subbins">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subbins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a tuple of the bin and subbins corresponding to the data_index.</span>

<span class="sd">        Paramteters</span>
<span class="sd">        -----------</span>

<span class="sd">        data_index : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        (bin[, subbin[, subbin ...]])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data_bin_index</span><span class="p">(</span><span class="n">data_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># Offset for data index in subbinning</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_subbins</span><span class="p">(</span><span class="n">data_index</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span> <span class="o">+</span> <span class="n">bins</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span></div>


<div class="viewcode-block" id="Binning.get_event_subbins">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_event_subbins">[docs]</a>
    <span class="k">def</span> <span class="nf">get_event_subbins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the tuple of subbins of the event.</span>

<span class="sd">        Returns `None` if the event does not fit in any bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : dict like</span>
<span class="sd">            A dictionary (or similar object) with one value of each variable</span>

<span class="sd">            in the binning, e.g.::</span>

<span class="sd">                {&#39;x&#39;: 1.4, &#39;y&#39;: -7.47}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ([bin[, subbin[, subbin ...]]) or None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subbins</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Binning.get_adjacent_bin_indices">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_adjacent_bin_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_adjacent_bin_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of adjacent bin indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        adjacent_indices : list of ndarray</span>
<span class="sd">            The adjacent indices of each bin</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The general case is that we just don&#39;t know which bin is adjacent to</span>
        <span class="c1"># which. Return a list of empty lists.</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span></div>


<div class="viewcode-block" id="Binning.get_adjacent_data_indices">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_adjacent_data_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_adjacent_data_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of adjacent data indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        adjacent_indices : list of ndarray</span>
<span class="sd">            The adjacent indices of each data index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Data indices inside a subbinning will only ever be adjacent to other</span>
<span class="sd">        indices inside the same subbinning. There is no information available</span>
<span class="sd">        about which bins in a subbinning are adjacent to which bins in the</span>
<span class="sd">        parent binning.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Start with adjacent bins</span>
        <span class="n">i_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacent_bin_indices</span><span class="p">()</span>

        <span class="c1"># Replace bin indices with data indices</span>
        <span class="c1"># and remove references to subbinnings</span>
        <span class="n">i_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_bin</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
                <span class="c1"># Regular bin</span>
                <span class="c1"># Add neighbouring bins translated to data indices</span>
                <span class="n">i_data</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
                        <span class="n">i_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                <span class="n">i_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Subbinning</span>
                <span class="c1"># Add its adjacent data indices offset to correct position</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">adj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_adjacent_data_indices</span><span class="p">():</span>
                    <span class="n">i_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adj</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">i_data</span></div>


<div class="viewcode-block" id="Binning.fill">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.fill">[docs]</a>
    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill the events into their respective bins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        event : [iterable of] dict like or Numpy structured array or Pandas DataFrame</span>
<span class="sd">            The event(s) to be filled into the binning.</span>
<span class="sd">        weight : float or iterable of floats, optional</span>
<span class="sd">            The weight of the event(s).</span>
<span class="sd">            Can be either a scalar which is then used for all events</span>
<span class="sd">            or an iterable of weights for the single events.</span>
<span class="sd">            Default: 1.</span>
<span class="sd">        raise_error : bool, optional</span>
<span class="sd">            Raise a ValueError if an event is not in the binning.</span>
<span class="sd">            Otherwise ignore the event.</span>
<span class="sd">            Default: False</span>
<span class="sd">        rename : dict, optional</span>
<span class="sd">            Dict for translating event variable names to binning variable names.</span>
<span class="sd">            Default: `{}`, i.e. no translation</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Empty iterable? Stop right here</span>
                <span class="k">return</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># Not an iterable</span>
            <span class="n">event</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">rename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rename</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rename</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Numpy array?</span>
                <span class="n">event</span> <span class="o">=</span> <span class="n">rename_fields</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">rename</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Pandas DataFrame?</span>
                    <span class="n">event</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">rename</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="c1"># Dict?</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">event</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">rename</span><span class="p">:</span>
                            <span class="n">e</span><span class="p">[</span><span class="n">rename</span><span class="p">[</span><span class="n">name</span><span class="p">]]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">ibins</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">ibins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to get bin numbers from a pandas DataFrame</span>
                <span class="n">ibins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">irow</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">(</span><span class="n">irow</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()),</span>
                        <span class="n">event</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># Seems like this is not a DataFrame</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">ibins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to get bin numbers from structured numpy array</span>
                <span class="n">ibins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">event</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># Seems like this is not a structured numpy array</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">ibins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to get bin numbers from any iterable of events</span>
                <span class="n">ibins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># We probably only have a single event</span>
                <span class="n">ibins</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">(</span><span class="n">event</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">raise_error</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">ibins</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Event not part of binning!&quot;</span><span class="p">)</span>

        <span class="c1"># Compare len of weight list and event list</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibins</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Different length of event and weight lists!&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="n">weight</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibins</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ibins</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fill_data_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span></div>


<div class="viewcode-block" id="Binning.fill_data_index">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.fill_data_index">[docs]</a>
    <span class="k">def</span> <span class="nf">fill_data_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the weight(s) to the given data position.</span>

<span class="sd">        Also increases the number of entries and sum of squared weights accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        i : int</span>
<span class="sd">            The index of the data arrays to be filled.</span>
<span class="sd">        weight : float or iterable of floats, optional</span>
<span class="sd">            Weight(s) to be added to the value of the bin.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Does the weight have a length?</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># No</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Yes</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
            <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w2</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_genfromtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replacement for numpy&#39;s genfromtxt, that should need less memory.&quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">namelist</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">namelist</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">namelist</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span>

            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">chunksize</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delimiter</span><span class="p">))))</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">arr</span>

    <span class="n">_csv_buffer</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_load_csv_file_buffered</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">chunksize</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load a CSV file and save the resulting array in a temporary file.</span>

<span class="sd">        If the same file is loaded a second time, the buffer is loaded instead</span>
<span class="sd">        of re-parsing the CSV file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_csv_buffer</span><span class="p">:</span>
            <span class="c1"># File has been loaded before</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_csv_buffer</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># New file</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">TemporaryFile</span><span class="p">()</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_genfromtxt</span><span class="p">(</span>
                <span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span>
            <span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_csv_buffer</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">arr</span>

<div class="viewcode-block" id="Binning.fill_multiple_from_csv_file">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.fill_multiple_from_csv_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fill_multiple_from_csv_file</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">binnings</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">,</span>
        <span class="n">weightfield</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">rename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cut_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">buffer_csv_files</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill multiple Binnings from the same csv file(s).</span>

<span class="sd">        This method saves time, because the numpy array only has to be</span>
<span class="sd">        generated once. Other than the list of binnings to be filled, the</span>
<span class="sd">        (keyword) arguments are identical to the ones used by the instance</span>
<span class="sd">        method :meth:`fill_from_csv_file`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">rename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rename</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Handle lists recursively</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">fill_multiple_from_csv_file</span><span class="p">(</span>
                        <span class="n">binnings</span><span class="p">,</span>
                        <span class="n">item</span><span class="p">,</span>
                        <span class="n">weightfield</span><span class="o">=</span><span class="n">weightfield</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                        <span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">,</span>
                        <span class="n">cut_function</span><span class="o">=</span><span class="n">cut_function</span><span class="p">,</span>
                        <span class="n">buffer_csv_files</span><span class="o">=</span><span class="n">buffer_csv_files</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">fill_multiple_from_csv_file</span><span class="p">(</span>
                        <span class="n">binnings</span><span class="p">,</span>
                        <span class="n">item</span><span class="p">,</span>
                        <span class="n">weightfield</span><span class="o">=</span><span class="n">weightfield</span><span class="p">,</span>
                        <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                        <span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">,</span>
                        <span class="n">cut_function</span><span class="o">=</span><span class="n">cut_function</span><span class="p">,</span>
                        <span class="n">buffer_csv_files</span><span class="o">=</span><span class="n">buffer_csv_files</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">buffer_csv_files</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_load_csv_file_buffered</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_genfromtxt</span><span class="p">(</span>
                <span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span>
            <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">rename_fields</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rename</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cut_function</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weightfield</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">weightfield</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span>

        <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="n">binnings</span><span class="p">:</span>
            <span class="n">binning</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Binning.fill_from_csv_file">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.fill_from_csv_file">[docs]</a>
    <span class="k">def</span> <span class="nf">fill_from_csv_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill the binning with events from a CSV file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        filename : string or list of strings</span>
<span class="sd">            The csv file with the data. Can be a list of filenames.</span>
<span class="sd">        weightfield : string, optional</span>
<span class="sd">            The column with the event weights.</span>
<span class="sd">        weight : float or iterable of floats, optional</span>
<span class="sd">            A single weight that will be applied to all events in the file.</span>
<span class="sd">            Can be an iterable with one weight for each file if `filename` is a list.</span>
<span class="sd">        rename : dict, optional</span>
<span class="sd">            A dict with columns that should be renamed before filling::</span>

<span class="sd">                {&#39;csv_name&#39;: &#39;binning_name&#39;}</span>

<span class="sd">        cut_function : function, optional</span>
<span class="sd">            A function that modifies the loaded data before filling into the binning,</span>
<span class="sd">            e.g.::</span>

<span class="sd">                cut_function(data) = data[ data[&#39;binning_name&#39;] &gt; some_threshold ]</span>

<span class="sd">            This is done *after* the optional renaming.</span>
<span class="sd">        buffer_csv_files : bool, optional</span>
<span class="sd">            Save the results of loading CSV files in temporary files</span>
<span class="sd">            that can be recovered if the same CSV file is loaded again. This</span>
<span class="sd">            speeds up filling multiple Binnings with the same CSV-files considerably!</span>
<span class="sd">            Default: False</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Load csv file in chunks of &lt;chunksize&gt; rows. This reduces the memory</span>
<span class="sd">            footprint of the loading operation, but can slow it down.</span>
<span class="sd">            Default: 10000</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        The file must be formated like this::</span>

<span class="sd">            first_varname,second_varname,...</span>
<span class="sd">            &lt;first_value&gt;,&lt;second_value&gt;,...</span>
<span class="sd">            &lt;first_value&gt;,&lt;second_value&gt;,...</span>
<span class="sd">            &lt;first_value&gt;,&lt;second_value&gt;,...</span>
<span class="sd">            ...</span>

<span class="sd">        For example::</span>

<span class="sd">            x,y,z</span>
<span class="sd">            1.0,2.1,3.2</span>
<span class="sd">            4.1,2.0,2.9</span>
<span class="sd">            3,2,1</span>

<span class="sd">        All values are interpreted as floats. If `weightfield` is given, that</span>
<span class="sd">        field will be used as weigts for the event. Other keyword arguments</span>
<span class="sd">        are passed on to the Binning&#39;s :meth:`fill` method. If filename is a list,</span>
<span class="sd">        all elemets are handled recursively.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Actual filling is handled by static method</span>
        <span class="n">Binning</span><span class="o">.</span><span class="n">fill_multiple_from_csv_file</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Binning.reset">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">entries</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sumw2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset all bin values to 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        value : float, optional</span>
<span class="sd">            Set the bin values to this value.</span>
<span class="sd">        entries : int, optional</span>
<span class="sd">            Set the number of entries in each bin to this value.</span>
<span class="sd">        sumw2 : float, optional</span>
<span class="sd">            Set the sum of squared weights in each bin to this value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">sumw2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Binning.get_values_as_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_values_as_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">get_values_as_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bin values as ndarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        shape: tuple of ints</span>
<span class="sd">            Shape of the resulting array.</span>
<span class="sd">            Default: ``(len(bins),)``</span>
<span class="sd">        indices: list of ints</span>
<span class="sd">            Only return the given bins.</span>
<span class="sd">            Default: Return all bins.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ndarray</span>
<span class="sd">            An ndarray with the values of the bins.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ret</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Binning.set_values_from_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.set_values_from_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">set_values_from_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the bin values to the values of the ndarray.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span></div>


<div class="viewcode-block" id="Binning.get_entries_as_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_entries_as_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">get_entries_as_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of entries in the bins as ndarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        shape: tuple of ints</span>
<span class="sd">            Shape of the resulting array.</span>
<span class="sd">            Default: ``(len(bins),)``</span>
<span class="sd">        indices: list of ints</span>
<span class="sd">            Only return the given bins.</span>
<span class="sd">            Default: Return all bins.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ndarray</span>
<span class="sd">            An ndarray with the numbers of entries of the bins.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ret</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Binning.set_entries_from_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.set_entries_from_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">set_entries_from_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the number of bin entries to the values of the ndarray.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span></div>


<div class="viewcode-block" id="Binning.get_sumw2_as_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.get_sumw2_as_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">get_sumw2_as_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sum of squared weights in the bins as ndarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        shape: tuple of ints</span>
<span class="sd">            Shape of the resulting array.</span>
<span class="sd">            Default: ``(len(bins),)``</span>
<span class="sd">        indices: list of ints</span>
<span class="sd">            Only return the given bins.</span>
<span class="sd">            Default: Return all bins.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        ndarray</span>
<span class="sd">            An ndarray with the sum of squared weights of the bins.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ret</span><span class="o">.</span><span class="n">size</span><span class="p">,),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Binning.set_sumw2_from_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.set_sumw2_from_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">set_sumw2_from_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the sums of squared weights to the values of the ndarray.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span></div>


<div class="viewcode-block" id="Binning.event_in_binning">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.event_in_binning">[docs]</a>
    <span class="k">def</span> <span class="nf">event_in_binning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether an event fits into any of the bins.&quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Binning.iter_subbins">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.iter_subbins">[docs]</a>
    <span class="k">def</span> <span class="nf">iter_subbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all bins and subbins.</span>

<span class="sd">        Will yield a tuple of the bins in this Binning and all subbinnings in</span>
<span class="sd">        the order they correspond to the data indices.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>

<span class="sd">        (bin[, subbin[, subbin ...]])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">iter_subbins</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span> <span class="o">+</span> <span class="n">sb</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">b</span><span class="p">,)</span></div>


<div class="viewcode-block" id="Binning.is_dummy">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.is_dummy">[docs]</a>
    <span class="k">def</span> <span class="nf">is_dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if there is no data array linked to this binning.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_in_binning</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Binnings are equal if all bins and the phase space are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bins</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">phasespace</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">subbinnings</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="Binning.marginalize_subbinnings_on_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.marginalize_subbinnings_on_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">marginalize_subbinnings_on_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">bin_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Marginalize out the bins corresponding to the subbinnings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        array : ndarray</span>
<span class="sd">            The data to work on.</span>
<span class="sd">        bin_indices : list of int, optional</span>
<span class="sd">            The bin indices of the subbinnings to be marginalized.</span>
<span class="sd">            If no indices are specified, all subbinnings are marginalized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        new_array : ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bin_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># Create working copy of input array</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

        <span class="c1"># Determine indices to be removed and set new values</span>
        <span class="n">remove_i</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bin_indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
                <span class="n">binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No subbinning at bin index </span><span class="si">%d</span><span class="s2">!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span>
            <span class="n">i_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">n_data</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">data_size</span>
            <span class="n">remove_i</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">i_data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i_data</span> <span class="o">+</span> <span class="n">n_data</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># Skip first one, since we substitute a single bin</span>

            <span class="c1"># Set marginalized value</span>
            <span class="n">new_array</span><span class="p">[</span><span class="n">i_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">new_array</span><span class="p">[</span><span class="n">i_data</span> <span class="p">:</span> <span class="n">i_data</span> <span class="o">+</span> <span class="n">n_data</span><span class="p">])</span>

        <span class="c1"># Remove marginalized elements</span>
        <span class="n">remove_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">remove_i</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">remove_i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_array</span></div>


<div class="viewcode-block" id="Binning.marginalize_subbinnings">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.marginalize_subbinnings">[docs]</a>
    <span class="k">def</span> <span class="nf">marginalize_subbinnings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a clone of the Binning with subbinnings removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bin_indices : list of int, optional</span>
<span class="sd">            The bin indices of the subbinnings to be marginalized.</span>
<span class="sd">            If no indices are specified, all subbinnings are marginalized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        new_binning : Binning</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bin_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># Clone the subbinnings that will remain in the binning</span>
        <span class="n">subbinnings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bin_indices</span><span class="p">:</span>
                <span class="n">binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">binning</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;subbinnings&quot;</span><span class="p">:</span> <span class="n">subbinnings</span><span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dummy</span><span class="p">():</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;value_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings_on_ndarray</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">,</span> <span class="n">bin_indices</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;entries_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings_on_ndarray</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">,</span> <span class="n">bin_indices</span>
                    <span class="p">),</span>
                    <span class="s2">&quot;sumw2_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings_on_ndarray</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">,</span> <span class="n">bin_indices</span>
                    <span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Binning.insert_subbinning_on_ndarray">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.insert_subbinning_on_ndarray">[docs]</a>
    <span class="k">def</span> <span class="nf">insert_subbinning_on_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">bin_index</span><span class="p">,</span> <span class="n">insert_array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert values of a new subbinning into the array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        array : ndarray</span>
<span class="sd">            The data to work on.</span>
<span class="sd">        bin_index : int</span>
<span class="sd">            The bin to be replaced with the subbinning.</span>
<span class="sd">        insert_array : ndarrau</span>
<span class="sd">            The array to be inserted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        new_array : ndarray</span>
<span class="sd">            The modified array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">bin_index</span><span class="p">)</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
            <span class="n">array</span><span class="p">,</span> <span class="n">i_data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">insert_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># Do not insert the first element</span>
        <span class="n">new_array</span><span class="p">[</span><span class="n">i_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">insert_array</span><span class="p">[</span>
            <span class="mi">0</span>
        <span class="p">]</span>  <span class="c1"># Instead set overwrite the values of the bin</span>
        <span class="k">return</span> <span class="n">new_array</span></div>


<div class="viewcode-block" id="Binning.insert_subbinning">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.insert_subbinning">[docs]</a>
    <span class="k">def</span> <span class="nf">insert_subbinning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_index</span><span class="p">,</span> <span class="n">binning</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a new subbinning into the binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bin_index : int</span>
<span class="sd">            The bin to be replaced with the subbinning.</span>
<span class="sd">        binning : Binning</span>
<span class="sd">            The new subbinning</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        new_binning : Binning</span>
<span class="sd">            A copy of this binning with the new subbinning.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>

<span class="sd">        This will replace the content of the bin with the content of the new</span>
<span class="sd">        subbinning!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bin_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bin </span><span class="si">%d</span><span class="s2"> already has a subbinning!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bin_index</span><span class="p">,))</span>

        <span class="n">subbinnings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">subbinnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">subbinnings</span><span class="p">[</span><span class="n">bin_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">binning</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;subbinnings&quot;</span><span class="p">:</span> <span class="n">subbinnings</span><span class="p">,</span>
            <span class="s2">&quot;value_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_subbinning_on_ndarray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">,</span> <span class="n">bin_index</span><span class="p">,</span> <span class="n">binning</span><span class="o">.</span><span class="n">value_array</span>
            <span class="p">),</span>
            <span class="s2">&quot;entries_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_subbinning_on_ndarray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">,</span> <span class="n">bin_index</span><span class="p">,</span> <span class="n">binning</span><span class="o">.</span><span class="n">entries_array</span>
            <span class="p">),</span>
            <span class="s2">&quot;sumw2_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert_subbinning_on_ndarray</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">,</span> <span class="n">bin_index</span><span class="p">,</span> <span class="n">binning</span><span class="o">.</span><span class="n">sumw2_array</span>
            <span class="p">),</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">set_values_from_ndarray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">set_entries_from_ndarray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">set_sumw2_from_ndarray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;subbinnings&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="n">i</span><span class="p">:</span> <span class="n">binning</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="s2">&quot;phasespace&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phasespace</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="s2">&quot;bins&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># Overwrite bins and do not re-create them one by one</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Re-create the bins one by one</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">bin</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dummy</span><span class="p">()</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dummy&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="s2">&quot;dummy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;value_array&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">),</span>
                    <span class="s2">&quot;entries_array&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">),</span>
                    <span class="s2">&quot;sumw2_array&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span>

<div class="viewcode-block" id="Binning.clone">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a functioning copy of the Binning.</span>

<span class="sd">        Can specify additional kwargs for the initialisation of the new Binning.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()]),</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Binning.to_yaml">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.to_yaml">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dumper</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_dummy</span><span class="p">():</span>
            <span class="k">del</span> <span class="n">dic</span><span class="p">[</span><span class="s2">&quot;dummy&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dumper</span><span class="o">.</span><span class="n">represent_mapping</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">yaml_tag</span><span class="p">,</span> <span class="n">dic</span><span class="p">)</span></div>


<div class="viewcode-block" id="Binning.from_yaml">
<a class="viewcode-back" href="../../modules/binning/Binning.html#remu.binning.Binning.from_yaml">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">dic</span><span class="p">)</span></div>


    <span class="n">yaml_loader</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">FullLoader</span>
    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!Binning&quot;</span></div>



<div class="viewcode-block" id="RectangularBinning">
<a class="viewcode-back" href="../../modules/binning/RectangularBinning.html#remu.binning.RectangularBinning">[docs]</a>
<span class="k">class</span> <span class="nc">RectangularBinning</span><span class="p">(</span><span class="n">Binning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Binning that contains only :class:`RectangularBin`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    variables : list of str</span>
<span class="sd">        The variables the binning is defined on.</span>

<span class="sd">    bin_edges : list of ((float, float), (float, float), ...)</span>
<span class="sd">        The list of bin edges defining the bins. The tuples contain the lower</span>
<span class="sd">        and upper edges of all `variables`, e.g.::</span>

<span class="sd">            [</span>
<span class="sd">            ((x_low, x_high), (y_low, y_high)),</span>
<span class="sd">            ((x_low, x_high), (y_low, y_high)),</span>
<span class="sd">            ...</span>
<span class="sd">            ]</span>

<span class="sd">    **kwargs : optional</span>
<span class="sd">        Additional keyword arguments will be passed to :class:`Binning`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    variables : tuple of str</span>
<span class="sd">        The variables corresponding to the bin edges.</span>
<span class="sd">    include_upper : bool</span>
<span class="sd">        Include the upper rather than the lower bin edges.</span>
<span class="sd">    bins : tuple of Bin</span>
<span class="sd">        The tuple of RectangularBins.</span>
<span class="sd">    nbins : int</span>
<span class="sd">        The number of bins in the binning.</span>
<span class="sd">    data_size : int</span>
<span class="sd">        The number of elements in the data arrays.</span>
<span class="sd">        Might differ from ``nbins`` due to subbinnings.</span>
<span class="sd">    subbinnings : dict of {bin_index: Binning}</span>
<span class="sd">        Subbinnings to replace certain bins.</span>
<span class="sd">    value_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the values of the bins are stored.</span>
<span class="sd">    entries_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the number of entries are stored.</span>
<span class="sd">    sumw2_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the squared weights are stored.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the binning resides in.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">include_upper</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">bin_edges</span><span class="p">:</span>
            <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">RectangularBin</span><span class="p">(</span>
                    <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
                    <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
                    <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
                    <span class="n">include_lower</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
                    <span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">Binning</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Turn all tuples into lists</span>
        <span class="k">for</span> <span class="n">bn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">:</span>
            <span class="n">bin_edges</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bn</span><span class="o">.</span><span class="n">edges</span><span class="p">])</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">variables</span><span class="p">),</span>
            <span class="s2">&quot;bin_edges&quot;</span><span class="p">:</span> <span class="n">bin_edges</span><span class="p">,</span>
            <span class="s2">&quot;include_upper&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Binning</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!RectangularBinning&quot;</span></div>



<span class="k">class</span> <span class="nc">_BinProxy</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all bin proxies.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binning</span> <span class="o">=</span> <span class="n">binning</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">nbins</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">binning</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>


<span class="k">class</span> <span class="nc">_CartesianProductBinProxy</span><span class="p">(</span><span class="n">_BinProxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indexable class that creates bins on the fly.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dynamically build an CartesianProductBin when requested.&quot;&quot;&quot;</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">get_bin_index_tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">val_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span><span class="n">index</span> <span class="p">:</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ent_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span><span class="n">index</span> <span class="p">:</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sumw2_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span><span class="n">index</span> <span class="p">:</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">binnings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">data_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
            <span class="n">binnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">binnings</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">data_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="nb">bin</span> <span class="o">=</span> <span class="n">CartesianProductBin</span><span class="p">(</span>
            <span class="n">binnings</span><span class="p">,</span>
            <span class="n">data_indices</span><span class="p">,</span>
            <span class="n">value_array</span><span class="o">=</span><span class="n">val_slice</span><span class="p">,</span>
            <span class="n">entries_array</span><span class="o">=</span><span class="n">ent_slice</span><span class="p">,</span>
            <span class="n">sumw2_array</span><span class="o">=</span><span class="n">sumw2_slice</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">bin</span>


<div class="viewcode-block" id="CartesianProductBinning">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning">[docs]</a>
<span class="k">class</span> <span class="nc">CartesianProductBinning</span><span class="p">(</span><span class="n">Binning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Binning that is the cartesian product of two or more Binnings</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    binnings : list of Binning</span>
<span class="sd">        The Binning objects to be multiplied.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    binnings : tuple of Binning</span>
<span class="sd">        The :class:`Binning` objects that make up the Cartesian product.</span>
<span class="sd">    bins : proxy for Bins</span>
<span class="sd">        Proxy that will generate :class:`CartesianProductBin` instances,</span>
<span class="sd">        when accessed.</span>
<span class="sd">    nbins : int</span>
<span class="sd">        The number of bins in the binning.</span>
<span class="sd">    bins_shape : tuple of int</span>
<span class="sd">        The sizes of the constituent binnings.</span>
<span class="sd">    data_size : int</span>
<span class="sd">        The number of elements in the data arrays.</span>
<span class="sd">        Might differ from ``nbins`` due to subbinnings.</span>
<span class="sd">    subbinnings : dict of {bin_index: Binning}</span>
<span class="sd">        Subbinnings to replace certain bins.</span>
<span class="sd">    value_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the values of the bins are stored.</span>
<span class="sd">    entries_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the number of entries are stored.</span>
<span class="sd">    sumw2_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the squared weights are stored.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the binning resides in.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    This creates a Binning with as many bins as the product of the number of</span>
<span class="sd">    bins in the iput binnings.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binnings</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">binnings</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bins_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">data_size</span> <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Calculate the step size (or stride) for each binning index.</span>
        <span class="c1"># We use a row-major ordering (C-style).</span>
        <span class="c1"># The index of the later binnings varies faster than the ones before:</span>
        <span class="c1">#</span>
        <span class="c1">#   (0,0) &lt;-&gt; 0</span>
        <span class="c1">#   (0,1) &lt;-&gt; 1</span>
        <span class="c1">#   (0,2) &lt;-&gt; 2</span>
        <span class="c1">#   (1,0) &lt;-&gt; 3</span>
        <span class="c1">#   ...</span>
        <span class="c1">#</span>
        <span class="c1"># _stepsize is 1 longer than binnings and bins_shape!</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">phasespace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phasespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phasespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create phasespace from binnings</span>
            <span class="n">phasespace</span> <span class="o">=</span> <span class="n">PhaseSpace</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">:</span>
                <span class="n">phasespace</span> <span class="o">*=</span> <span class="n">binning</span><span class="o">.</span><span class="n">phasespace</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;phasespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phasespace</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bins&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot define bins of CartesianProductBinning! Define binnings instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create bin proxy</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">_CartesianProductBinProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span>
        <span class="n">Binning</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_link_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We do not need to link each bin separately,</span>
        <span class="c1"># the bin proxy takes care of this</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="CartesianProductBinning.get_tuple_bin_index">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning.get_tuple_bin_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_tuple_bin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tup</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate a tuple of binning specific bin indices to the linear bin index of the event.</span>

<span class="sd">        Turns this::</span>

<span class="sd">            (i_x, i_y, i_z)</span>

<span class="sd">        into this::</span>

<span class="sd">            i_bin</span>

<span class="sd">        The order of the indices in the tuple must conform to the order of</span>
<span class="sd">        `binnings`. The bins are ordered row-major (C-style), i.e. increasing</span>
<span class="sd">        the bin number of the last binning by one increases the overall bin</span>
<span class="sd">        number also by one. The increments of the other variables depend on the</span>
<span class="sd">        number of bins in each variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">i_bin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">i_bin</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">i</span>

        <span class="k">return</span> <span class="n">i_bin</span></div>


<div class="viewcode-block" id="CartesianProductBinning.get_bin_index_tuple">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning.get_bin_index_tuple">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bin_index_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_bin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate the linear bin index of the event to a tuple of single binning bin indices.</span>

<span class="sd">        Turns this::</span>

<span class="sd">            i_bin</span>

<span class="sd">        into this::</span>

<span class="sd">            (i_x, i_y, i_z)</span>

<span class="sd">        The order of the indices in the tuple conforms to the order of</span>
<span class="sd">        `binnings`. The bins are ordered row-major (C-style), i.e. increasing</span>
<span class="sd">        the bin number of the last variable by one increases the overall bin</span>
<span class="sd">        number also by one. The increments of the other variables depend on the</span>
<span class="sd">        number of bins in each variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">i_bin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i_bin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i_bin</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">))</span>

        <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">i_bin</span> <span class="o">%</span> <span class="n">t</span><span class="p">)</span> <span class="o">//</span> <span class="n">s</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stepsize</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tup</span></div>


<div class="viewcode-block" id="CartesianProductBinning.get_event_tuple">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning.get_event_tuple">[docs]</a>
    <span class="k">def</span> <span class="nf">get_event_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the variable index tuple for a given event.&quot;&quot;&quot;</span>

        <span class="n">tup</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">get_event_data_index</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
            <span class="n">tup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span></div>


<div class="viewcode-block" id="CartesianProductBinning.get_event_bin_index">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning.get_event_bin_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_event_bin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the bin index for a given event.&quot;&quot;&quot;</span>

        <span class="n">tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_tuple</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tuple_bin_index</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span></div>


<div class="viewcode-block" id="CartesianProductBinning.get_adjacent_bin_indices">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning.get_adjacent_bin_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_adjacent_bin_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of adjacent bin indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        adjacent_indices : list of ndarray</span>
<span class="sd">            The adjacent indices of each bin</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Adjacent bins are based on the adjacent data indices of the</span>
        <span class="c1"># constituting binnings</span>

        <span class="n">adj_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">get_adjacent_data_indices</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">)</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># For all bins</span>
        <span class="k">for</span> <span class="n">i_bin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">):</span>
            <span class="n">i_adj</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Get the tuple of binning data indices</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bin_index_tuple</span><span class="p">(</span><span class="n">i_bin</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i_binning</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)):</span>
                <span class="n">variations</span> <span class="o">=</span> <span class="n">adj_tuple</span><span class="p">[</span><span class="n">i_binning</span><span class="p">][</span><span class="n">tup</span><span class="p">[</span><span class="n">i_binning</span><span class="p">]]</span>
                <span class="n">var_tup</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">variations</span><span class="p">:</span>
                    <span class="n">var_tup</span><span class="p">[</span><span class="n">i_binning</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">i_adj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tuple_bin_index</span><span class="p">(</span><span class="n">var_tup</span><span class="p">))</span>
            <span class="n">adj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">i_adj</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">adj</span></div>


<div class="viewcode-block" id="CartesianProductBinning.marginalize">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning.marginalize">[docs]</a>
    <span class="k">def</span> <span class="nf">marginalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning_i</span><span class="p">,</span> <span class="n">reduction_function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Marginalize out the given binnings and return a new CartesianProductBinning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        binning_i : iterable of int</span>
<span class="sd">            Iterable of index of binning to be marginalized.</span>
<span class="sd">        reduction_function : function</span>
<span class="sd">            Use this function to marginalize out the entries over the specified variables.</span>
<span class="sd">            Must support the `axis` keyword argument.</span>
<span class="sd">            Default: numpy.sum</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">binning_i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">binning_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">binning_i</span><span class="p">]</span>

        <span class="c1"># Create new binning</span>
        <span class="n">new_binnings</span> <span class="o">=</span> <span class="p">[</span><span class="n">binning</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">binning_i</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">new_binnings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">CartesianProductBinning</span><span class="p">(</span><span class="n">new_binnings</span><span class="p">)</span>

        <span class="c1"># Copy and project values, from binning without subbinnings</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">binning_i</span><span class="p">))</span>
        <span class="n">temp_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings</span><span class="p">()</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">reduction_function</span><span class="p">(</span>
            <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span>
        <span class="p">)</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">reduction_function</span><span class="p">(</span>
            <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">reduction_function</span><span class="p">(</span>
            <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span>
        <span class="p">)</span>

        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_values_from_ndarray</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_entries_from_ndarray</span><span class="p">(</span><span class="n">new_entries</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_sumw2_from_ndarray</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_binning</span></div>


    <span class="k">def</span> <span class="nf">_unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the unpacked last remaining binning.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unpacking only works if there is exactly one binning.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Unpacking only works if there is exactly zero subbinnings.&quot;</span>
            <span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;value_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_array</span><span class="p">,</span>
            <span class="s2">&quot;entries_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">entries_array</span><span class="p">,</span>
            <span class="s2">&quot;sumw2_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">,</span>
            <span class="s2">&quot;dummy&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="CartesianProductBinning.project">
<a class="viewcode-back" href="../../modules/binning/CartesianProductBinning.html#remu.binning.CartesianProductBinning.project">[docs]</a>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project the binning onto the given binnings and return a new CartesianProductBinning.</span>

<span class="sd">        The order of the original binnings is preserved. If a single ``int`` is</span>
<span class="sd">        provided, the returned Binning is of the same type as the respective</span>
<span class="sd">        binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        binning_i : iterable of int, or int</span>
<span class="sd">            Iterable of index of binning to be marginalized.</span>
<span class="sd">        kwargs : optional</span>
<span class="sd">            Additional keyword arguments are passed on to :meth:`marginalize`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        CartesianProductBinning or type(self.binnings[binning_i])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">binning_i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">binning_i</span><span class="p">]</span>

        <span class="c1"># Which variables to remove</span>
        <span class="n">rm_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">)))</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">rm_i</span><span class="o">.</span><span class="n">remove</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">rm_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning_i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">_unpack</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CartesianProductBinnings are equal if the included Binnings match.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">binnings</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">subbinnings</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;binnings&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">binning</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Binning</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!CartesianProductBinning&quot;</span></div>



<span class="k">class</span> <span class="nc">_LinearBinProxy</span><span class="p">(</span><span class="n">_BinProxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indexable class that creates bins on the fly.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dynamically build a RectangularBin when requested.&quot;&quot;&quot;</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">data_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">variable</span><span class="p">],</span>
            <span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)],</span>
            <span class="s2">&quot;include_lower&quot;</span><span class="p">:</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
            <span class="s2">&quot;include_upper&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">is_dummy</span><span class="p">():</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;value_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span>
                        <span class="n">data_index</span> <span class="p">:</span> <span class="n">data_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;entries_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span>
                        <span class="n">data_index</span> <span class="p">:</span> <span class="n">data_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;sumw2_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span>
                        <span class="n">data_index</span> <span class="p">:</span> <span class="n">data_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">],</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="n">rbin</span> <span class="o">=</span> <span class="n">RectangularBin</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rbin</span>


<div class="viewcode-block" id="LinearBinning">
<a class="viewcode-back" href="../../modules/binning/LinearBinning.html#remu.binning.LinearBinning">[docs]</a>
<span class="k">class</span> <span class="nc">LinearBinning</span><span class="p">(</span><span class="n">Binning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple binning, defined by bin edges on a single variable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    variable : str</span>
<span class="sd">        The name of te defining variable.</span>
<span class="sd">    bin_edges : list of float</span>
<span class="sd">        The bin edges defining the bins.</span>
<span class="sd">    include_upper : bool, optional</span>
<span class="sd">        Include the upper edge of bins instead of the default lower edge.</span>
<span class="sd">    **kwargs : optional</span>
<span class="sd">        Additional keyword arguments are handed to :class:`Binning`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    variable : str</span>
<span class="sd">        The variable on which the bin edges are defined.</span>
<span class="sd">    bin_edges : ndarray</span>
<span class="sd">        The bin edges.</span>
<span class="sd">    include_upper : bool</span>
<span class="sd">        Are the upper edges included in each bin?</span>
<span class="sd">    bins : proxy for Bins</span>
<span class="sd">        Proxy that will generate :class:`RectangularBin` instances,</span>
<span class="sd">        when accessed.</span>
<span class="sd">    nbins : int</span>
<span class="sd">        The number of bins in the binning.</span>
<span class="sd">    data_size : int</span>
<span class="sd">        The number of elements in the data arrays.</span>
<span class="sd">        Might differ from ``nbins`` due to subbinnings.</span>
<span class="sd">    subbinnings : dict of {bin_index: Binning}, optional</span>
<span class="sd">        Subbinnings to replace certain bins.</span>
<span class="sd">    value_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the values of the bins are stored.</span>
<span class="sd">    entries_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the number of entries are stored.</span>
<span class="sd">    sumw2_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the squared weights are stored.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the binning resides in.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">include_upper</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">phasespace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phasespace&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phasespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create phasespace from variable</span>
            <span class="n">phasespace</span> <span class="o">=</span> <span class="n">PhaseSpace</span><span class="p">([</span><span class="n">variable</span><span class="p">])</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;phasespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phasespace</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bins&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot define bins of LinearBinning! Define bin edges instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create bin proxy</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">_LinearBinProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span>
        <span class="n">Binning</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_link_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># We do not need to link each bin separately,</span>
        <span class="c1"># the bin proxy takes care of this</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="LinearBinning.get_event_bin_index">
<a class="viewcode-back" href="../../modules/binning/LinearBinning.html#remu.binning.LinearBinning.get_event_bin_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_event_bin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the bin index for a given event.&quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Deal with Numpy&#39;s way of handling over- and underflows</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">i</span></div>


<div class="viewcode-block" id="LinearBinning.get_adjacent_bin_indices">
<a class="viewcode-back" href="../../modules/binning/LinearBinning.html#remu.binning.LinearBinning.get_adjacent_bin_indices">[docs]</a>
    <span class="k">def</span> <span class="nf">get_adjacent_bin_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of adjacent bin indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        adjacent_indices : list of ndarray</span>
<span class="sd">            The adjacent indices of each bin</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Adjacent bins are the ones before and after</span>
        <span class="n">i_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">i_bin_m</span> <span class="o">=</span> <span class="n">i_bin</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">i_bin_p</span> <span class="o">=</span> <span class="n">i_bin</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">adj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">i_bin_m</span><span class="p">,</span> <span class="n">i_bin_p</span><span class="p">))</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">adj</span><span class="p">))</span>
        <span class="c1"># Remove out of range elements</span>
        <span class="n">adj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">adj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">adj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">adj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">adj</span></div>


<div class="viewcode-block" id="LinearBinning.slice">
<a class="viewcode-back" href="../../modules/binning/LinearBinning.html#remu.binning.LinearBinning.slice">[docs]</a>
    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new LinearBinning containing the given variable slice</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        start : int</span>
<span class="sd">        end : int</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            The start and stop positions as used with Python slice objects.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sliced_binning : LinearBinning</span>
<span class="sd">            A :class:`LinearBinning` consisting of the specified slice.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This will remove any ``subbinnings`` the linear binning might have.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bin_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

        <span class="c1"># Create new binning</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">bin_slice</span><span class="p">]</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">bin_slice</span><span class="p">]</span>
        <span class="n">new_bin_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">upper</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">LinearBinning</span><span class="p">(</span>
            <span class="n">variable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="n">new_bin_edges</span><span class="p">,</span>
            <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Copy and slice values</span>
        <span class="n">temp_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings</span><span class="p">()</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">()[</span><span class="n">bin_slice</span><span class="p">]</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">()[</span><span class="n">bin_slice</span><span class="p">]</span>
        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">()[</span><span class="n">bin_slice</span><span class="p">]</span>

        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_values_from_ndarray</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_entries_from_ndarray</span><span class="p">(</span><span class="n">new_entries</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_sumw2_from_ndarray</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_binning</span></div>


<div class="viewcode-block" id="LinearBinning.remove_bin_edges">
<a class="viewcode-back" href="../../modules/binning/LinearBinning.html#remu.binning.LinearBinning.remove_bin_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_edge_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new LinearBinning with the given bin edges removed.</span>

<span class="sd">        The values of the bins adjacent to the removed bin edges will be</span>
<span class="sd">        summed up in the resulting larger bin. Please note that bin values</span>
<span class="sd">        are lost if the first or last binedge of a variable are removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bin_edge_indices : lists of integers</span>
<span class="sd">            A list specifying the bin edge indices that should be removed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This will remove any ``subbinnings`` the linear binning might have.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create new binning</span>
        <span class="n">new_bin_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bin_edge_indices</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">new_bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">LinearBinning</span><span class="p">(</span>
            <span class="n">variable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="n">new_bin_edges</span><span class="p">,</span>
            <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Copy and slice values</span>
        <span class="n">temp_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings</span><span class="p">()</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">()</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">()</span>
        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bin_edge_indices</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">new_values</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">new_values</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">new_entries</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">new_sumw2</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_sumw2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">new_values</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">new_entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_entries</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">new_entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_entries</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_values_from_ndarray</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_entries_from_ndarray</span><span class="p">(</span><span class="n">new_entries</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_sumw2_from_ndarray</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_binning</span></div>


    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
            <span class="s2">&quot;bin_edges&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;include_upper&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Binning</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Linear binnings are equal if the variable and edges match.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">variable</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">include_upper</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">subbinnings</span>
        <span class="p">)</span>

    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!LinearBinning&quot;</span></div>



<span class="k">class</span> <span class="nc">_RectilinearBinProxy</span><span class="p">(</span><span class="n">_BinProxy</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indexable class that creates bins on the fly.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dynamically build a RectangularBin when requested.&quot;&quot;&quot;</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">get_bin_index_tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">edg</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">edg</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">edg</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">tup</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">data_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">get_bin_data_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="n">edges</span><span class="p">,</span>
            <span class="s2">&quot;include_lower&quot;</span><span class="p">:</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
            <span class="s2">&quot;include_upper&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">is_dummy</span><span class="p">():</span>
            <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;value_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">value_array</span><span class="p">[</span>
                        <span class="n">data_index</span> <span class="p">:</span> <span class="n">data_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;entries_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">entries_array</span><span class="p">[</span>
                        <span class="n">data_index</span> <span class="p">:</span> <span class="n">data_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;sumw2_array&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">sumw2_array</span><span class="p">[</span>
                        <span class="n">data_index</span> <span class="p">:</span> <span class="n">data_index</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">],</span>
                <span class="p">}</span>
            <span class="p">)</span>
        <span class="n">rbin</span> <span class="o">=</span> <span class="n">RectangularBin</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rbin</span>


<div class="viewcode-block" id="RectilinearBinning">
<a class="viewcode-back" href="../../modules/binning/RectilinearBinning.html#remu.binning.RectilinearBinning">[docs]</a>
<span class="k">class</span> <span class="nc">RectilinearBinning</span><span class="p">(</span><span class="n">CartesianProductBinning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special case of :class:`CartesianProductBinning` only consisting of :class:`LinearBinning`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    variables : iterable of str</span>
<span class="sd">    bin_edges :  iterable of iterable of float</span>
<span class="sd">        The variable names and bin edges for the LinearBinnings.</span>
<span class="sd">    include_upper : bool, optional</span>
<span class="sd">        Make bins include upper edges instead of lower edges.</span>
<span class="sd">    **kwargs : optional</span>
<span class="sd">        Additional keyword arguments will be passed to :class:`CartesianProductBinning`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    variables : tuple of str</span>
<span class="sd">        The variables on which the bin edges are defined.</span>
<span class="sd">    bin_edges : tuple of ndarray</span>
<span class="sd">        The bin edges defining the :class:`LinearBinning` objects.</span>
<span class="sd">    include_upper : bool</span>
<span class="sd">        Are the upper edges included in each bin?</span>
<span class="sd">    binnings : list of LinearBinning</span>
<span class="sd">        The :class:`LinearBinning` objects that make up the Cartesian product.</span>
<span class="sd">    bins : list of Bin</span>
<span class="sd">        The :class:`RectangularBin` instances.</span>
<span class="sd">    nbins : int</span>
<span class="sd">        The number of bins in the binning.</span>
<span class="sd">    bins_shape : tuple of int</span>
<span class="sd">        The sizes of the constituent binnings.</span>
<span class="sd">    data_size : int</span>
<span class="sd">        The number of elements in the data arrays.</span>
<span class="sd">        Might differ from ``nbins`` due to subbinnings.</span>
<span class="sd">    subbinnings : dict of {bin_index: Binning}, optional</span>
<span class="sd">        Subbinnings to replace certain bins.</span>
<span class="sd">    value_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the values of the bins are stored.</span>
<span class="sd">    entries_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the number of entries are stored.</span>
<span class="sd">    sumw2_array : slice of ndarray</span>
<span class="sd">        A slice of a numpy array, where the squared weights are stored.</span>
<span class="sd">    phasespace : PhaseSpace</span>
<span class="sd">        The :class:`PhaseSpace` the binning resides in.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edg</span><span class="p">)</span> <span class="k">for</span> <span class="n">edg</span> <span class="ow">in</span> <span class="n">bin_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">include_upper</span><span class="p">)</span>

        <span class="n">binnings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">edges</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">):</span>
            <span class="n">binnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">LinearBinning</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">include_upper</span><span class="o">=</span><span class="n">include_upper</span><span class="p">,</span> <span class="n">dummy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;binnings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binnings</span>

        <span class="n">bins</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bins&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot define bins of RectilinearBinning! Define bin edges instead.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create bin proxy</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">_RectilinearBinProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">CartesianProductBinning</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Replace cartesian proxy with one returning rectangular bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span>

<div class="viewcode-block" id="RectilinearBinning.get_variable_index">
<a class="viewcode-back" href="../../modules/binning/RectilinearBinning.html#remu.binning.RectilinearBinning.get_variable_index">[docs]</a>
    <span class="k">def</span> <span class="nf">get_variable_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the index of the binning corresponding to this variable.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">variable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span></div>


<div class="viewcode-block" id="RectilinearBinning.marginalize">
<a class="viewcode-back" href="../../modules/binning/RectilinearBinning.html#remu.binning.RectilinearBinning.marginalize">[docs]</a>
    <span class="k">def</span> <span class="nf">marginalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning_i</span><span class="p">,</span> <span class="n">reduction_function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Marginalize out the given binnings and return a new RectilinearBinning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        binning_i : iterable of int/str</span>
<span class="sd">            Iterable of index/variable of binning to be marginalized.</span>
<span class="sd">        reduction_function : function</span>
<span class="sd">            Use this function to marginalize out the entries over the specified variables.</span>
<span class="sd">            Must support the `axis` keyword argument.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">binning_i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">binning_i</span> <span class="o">=</span> <span class="p">[</span><span class="n">binning_i</span><span class="p">]</span>

        <span class="n">binning_i</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_variable_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">binning_i</span><span class="p">]</span>

        <span class="c1"># Create new binning</span>
        <span class="n">new_variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">new_bin_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">binning_i</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">new_bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">new_variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">RectilinearBinning</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">new_variables</span><span class="p">,</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="n">new_bin_edges</span><span class="p">,</span>
            <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Copy and project values, from binning without subbinnings</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">binning_i</span><span class="p">))</span>
        <span class="n">temp_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings</span><span class="p">()</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">reduction_function</span><span class="p">(</span>
            <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span>
        <span class="p">)</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">reduction_function</span><span class="p">(</span>
            <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">),</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">reduction_function</span><span class="p">(</span>
            <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axes</span>
        <span class="p">)</span>

        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_values_from_ndarray</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_entries_from_ndarray</span><span class="p">(</span><span class="n">new_entries</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_sumw2_from_ndarray</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_binning</span></div>


<div class="viewcode-block" id="RectilinearBinning.project">
<a class="viewcode-back" href="../../modules/binning/RectilinearBinning.html#remu.binning.RectilinearBinning.project">[docs]</a>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project the binning onto the given binnings and return a new RectilinearBinning.</span>

<span class="sd">        The order of the original binnings is preserved. If a single ``int`` is</span>
<span class="sd">        provided, the returned Binning is of the same type as the respective</span>
<span class="sd">        binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        binning_i : iterable of int/str, or int/str</span>
<span class="sd">            Iterable of index of binning to be marginalized.</span>
<span class="sd">        **kwargs : optional</span>
<span class="sd">            Additional keyword arguments are passed on to :meth:`marginalize`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        RectilinearBinning or type(self.binnings[binning_i])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">binning_i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">binning_i</span><span class="p">]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_variable_index</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">binning_i</span><span class="p">]</span>

        <span class="c1"># Which variables to remove</span>
        <span class="n">rm_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binnings</span><span class="p">)))</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">rm_i</span><span class="o">.</span><span class="n">remove</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize</span><span class="p">(</span><span class="n">rm_i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning_i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning_i</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">_unpack</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="RectilinearBinning.slice">
<a class="viewcode-back" href="../../modules/binning/RectilinearBinning.html#remu.binning.RectilinearBinning.slice">[docs]</a>
    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new RectilinearBinning containing the given variable slice</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        slices : dict of (variable, (start, stop[, step]))</span>
<span class="sd">            The start and stop positions for the slices of all variables that</span>
<span class="sd">            should be sliced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        sliced_binning : RectilinearBinning</span>
<span class="sd">            A :class:`RectilinearBinning` consisting of the specified slices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This will remove any ``subbinnings`` the binning might have.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create new binning edges and slice tuple</span>
        <span class="n">new_bin_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">))</span>
        <span class="n">all_slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
                <span class="n">bin_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">slices</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">bin_slice</span><span class="p">]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">bin_slice</span><span class="p">]</span>
                <span class="n">new_bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">upper</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">all_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_slice</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This variable does not have to be sliced</span>
                <span class="n">all_slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="n">all_slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_slices</span><span class="p">)</span>

        <span class="c1"># Create new binning</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">RectilinearBinning</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="n">new_bin_edges</span><span class="p">,</span>
            <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Copy and slice values</span>
        <span class="n">temp_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings</span><span class="p">()</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">)[</span>
            <span class="n">all_slices</span>
        <span class="p">]</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span>
        <span class="p">)[</span><span class="n">all_slices</span><span class="p">]</span>
        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">)[</span>
            <span class="n">all_slices</span>
        <span class="p">]</span>

        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_values_from_ndarray</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_entries_from_ndarray</span><span class="p">(</span><span class="n">new_entries</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_sumw2_from_ndarray</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_binning</span></div>


<div class="viewcode-block" id="RectilinearBinning.remove_bin_edges">
<a class="viewcode-back" href="../../modules/binning/RectilinearBinning.html#remu.binning.RectilinearBinning.remove_bin_edges">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_edge_indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new RectilinearBinning with the given bin edges removed.</span>

<span class="sd">        The values of the bins adjacent to the removed bin edges will be</span>
<span class="sd">        summed up in the resulting larger bin. Please note that bin values</span>
<span class="sd">        are lost if the first or last binedge of a variable are removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bin_edge_indices : dict of (variable: list of int)</span>
<span class="sd">            Lists specifying the bin edge indices that should be removed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This will remove any ``subbinnings`` the rectilinear binning might have.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create new binning</span>
        <span class="n">new_bin_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">edg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">):</span>
            <span class="n">new_edg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">bin_edge_indices</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bin_edge_indices</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">new_edg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_bin_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_edg</span><span class="p">)</span>

        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">RectilinearBinning</span><span class="p">(</span>
            <span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="n">new_bin_edges</span><span class="p">,</span>
            <span class="n">include_upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Copy and slice values</span>
        <span class="n">temp_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marginalize_subbinnings</span><span class="p">()</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_values_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">)</span>
        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_entries_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">)</span>
        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">temp_binning</span><span class="o">.</span><span class="n">get_sumw2_as_ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">temp_binning</span><span class="o">.</span><span class="n">bins_shape</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">bin_edge_indices</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bin_edge_indices</span><span class="p">[</span><span class="n">var</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">new_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">lower_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,)</span>
                        <span class="n">upper_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,)</span>
                        <span class="n">new_values</span><span class="p">[</span><span class="n">lower_tuple</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_values</span><span class="p">[</span><span class="n">upper_tuple</span><span class="p">]</span>
                        <span class="n">new_entries</span><span class="p">[</span><span class="n">lower_tuple</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_entries</span><span class="p">[</span><span class="n">upper_tuple</span><span class="p">]</span>
                        <span class="n">new_sumw2</span><span class="p">[</span><span class="n">lower_tuple</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_sumw2</span><span class="p">[</span><span class="n">upper_tuple</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">new_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_entries</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">new_entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_entries</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">new_sumw2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>

        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_values_from_ndarray</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_entries_from_ndarray</span><span class="p">(</span><span class="n">new_entries</span><span class="p">)</span>
        <span class="n">new_binning</span><span class="o">.</span><span class="n">set_sumw2_from_ndarray</span><span class="p">(</span><span class="n">new_sumw2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_binning</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;RectilinearBinnings are equal if the bin edges and variables match.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">variables</span>
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">include_upper</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">subbinnings</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">subbinnings</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the necessary arguments to clone this object.&quot;&quot;&quot;</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;variables&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span>
            <span class="s2">&quot;bin_edges&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">edg</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">edg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">],</span>
            <span class="s2">&quot;include_upper&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_upper</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Binning</span><span class="o">.</span><span class="n">_get_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;bins&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="n">yaml_tag</span> <span class="o">=</span> <span class="s2">&quot;!RectilinearBinning&quot;</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Lukas Koch.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>